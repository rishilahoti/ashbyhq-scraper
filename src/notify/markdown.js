const fs = require('fs');
const path = require('path');
const config = require('../config');
const { EVENT_TYPES } = require('../diff');
const { logger } = require('../utils');

function generateReport(allChanges, scoredJobs) {
  const now = new Date();
  const dateStr = now.toISOString().slice(0, 10);
  const timeStr = now.toISOString().slice(11, 16);

  const lines = [
    `# Job Scraper Report — ${dateStr}`,
    '',
    `> Generated at ${dateStr} ${timeStr} UTC`,
    '',
  ];

  const newJobs = allChanges.filter(c => c.type === EVENT_TYPES.JOB_NEW);
  const updatedJobs = allChanges.filter(c => c.type === EVENT_TYPES.JOB_UPDATED);
  const removedJobs = allChanges.filter(c => c.type === EVENT_TYPES.JOB_REMOVED);

  lines.push(`## Summary`);
  lines.push('');
  lines.push(`| Metric | Count |`);
  lines.push(`|--------|-------|`);
  lines.push(`| New Jobs | ${newJobs.length} |`);
  lines.push(`| Updated Jobs | ${updatedJobs.length} |`);
  lines.push(`| Removed Jobs | ${removedJobs.length} |`);
  lines.push(`| Above Relevance Threshold | ${scoredJobs?.length || 0} |`);
  lines.push('');

  if (scoredJobs && scoredJobs.length > 0) {
    lines.push('## Top Opportunities');
    lines.push('');
    for (const job of scoredJobs.slice(0, 20)) {
      lines.push(`### ${job.title} — ${job.company}`);
      lines.push('');
      lines.push(`- **Score:** ${job.relevanceScore}`);
      lines.push(`- **Location:** ${job.location}${job.remote ? ' (Remote)' : ''}`);
      if (job.department) lines.push(`- **Department:** ${job.department}`);
      if (job.team) lines.push(`- **Team:** ${job.team}`);
      if (job.employmentType) lines.push(`- **Type:** ${job.employmentType}`);
      if (job.compensationSummary) lines.push(`- **Compensation:** ${job.compensationSummary}`);
      lines.push(`- **Signals:** ${job.signals.join(', ')}`);
      lines.push(`- **Apply:** [Link](${job.applyUrl})`);
      lines.push('');
    }
  }

  if (newJobs.length > 0) {
    lines.push('## New Postings');
    lines.push('');
    for (const { job } of newJobs) {
      lines.push(`- **${job.title}** at ${job.company} — ${job.location}${job.remote ? ' (Remote)' : ''} — [Apply](${job.applyUrl})`);
    }
    lines.push('');
  }

  if (updatedJobs.length > 0) {
    lines.push('## Updated Postings');
    lines.push('');
    for (const { job } of updatedJobs) {
      lines.push(`- **${job.title}** at ${job.company} — ${job.location}`);
    }
    lines.push('');
  }

  if (removedJobs.length > 0) {
    lines.push('## Removed Postings');
    lines.push('');
    for (const { job } of removedJobs) {
      lines.push(`- ~~${job.title}~~ at ${job.company} — ${job.location}`);
    }
    lines.push('');
  }

  lines.push('---');
  lines.push(`*Generated by AshbyHQ Job Scraper*`);

  const content = lines.join('\n');
  const reportPath = writeReport(dateStr, content);
  return reportPath;
}

function writeReport(dateStr, content) {
  const dir = path.resolve(config.notify.reportsDir);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  const filePath = path.join(dir, `${dateStr}.md`);

  if (fs.existsSync(filePath)) {
    const timestamp = Date.now();
    const altPath = path.join(dir, `${dateStr}-${timestamp}.md`);
    fs.writeFileSync(altPath, content, 'utf-8');
    logger.info(`Report written to ${altPath}`);
    return altPath;
  }

  fs.writeFileSync(filePath, content, 'utf-8');
  logger.info(`Report written to ${filePath}`);
  return filePath;
}

async function generateReportFromDb(store, intelligence) {
  const activeJobs = await store.getAllActiveJobs();

  const normalized = activeJobs.map(row => ({
    jobId: row.job_id,
    company: row.company,
    title: row.title,
    location: row.location,
    team: row.team,
    department: row.department,
    employmentType: row.employment_type,
    remote: Boolean(row.remote),
    description: row.description,
    applyUrl: row.apply_url,
    jobUrl: row.job_url,
    publishedAt: row.published_at,
    compensationSummary: row.compensation_summary,
  }));

  const { filtered } = intelligence.filterAndRank(normalized);

  const reportPath = generateReport([], filtered);
  return reportPath;
}

module.exports = { generateReport, generateReportFromDb };
